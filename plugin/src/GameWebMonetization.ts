/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       gammafp
 * @author       Dacio Romero (Web Monetization Event TypeScript Defs)
 * @copyright    2021 Photon Storm Ltd.
 */

import { EventEmitter } from 'eventemitter3';

interface BaseMonetizationEventDetail
{
    paymentPointer: string;
    requestId: string;
}
  
export interface MonetizationPendingEvent extends CustomEvent<BaseMonetizationEventDetail>
{
    type: 'monetizationpending';
}

export interface MonetizationStartEvent extends CustomEvent<BaseMonetizationEventDetail>
{
    type: 'monetizationstart';
}

interface MonetizationStopEventDetail extends BaseMonetizationEventDetail
{
    finalized: boolean;
}

export interface MonetizationStopEvent extends CustomEvent<MonetizationStopEventDetail>
{
    type: 'monetizationstop';
}

interface MonetizationProgressEventDetail extends BaseMonetizationEventDetail
{
    amount: string;
    assetCode: string;
    assetScale: number;
}

export interface MonetizationProgressEvent extends CustomEvent<MonetizationProgressEventDetail>
{
    type: 'monetizationprogress';
}

export interface MonetizationEventMap
{
    monetizationpending: MonetizationPendingEvent;
    monetizationstart: MonetizationStartEvent;
    monetizationstop: MonetizationStopEvent;
    monetizationprogress: MonetizationProgressEvent;
}

export type MonetizationEvent = MonetizationEventMap[keyof MonetizationEventMap];

export type MonetizationState = 'stopped' | 'pending' | 'started';

type EventListener<T, E extends Event = Event> = (this: T, evt: E) => any;

interface EventListenerObject<T, E extends Event = Event>
{
    handleEvent(this: T, evt: E): void;
}

type EventListenerOrListenerObject<T, E extends Event = Event> = | EventListener<T, E> | EventListenerObject<T, E>;

export interface Monetization extends EventTarget
{
    state: MonetizationState;

    addEventListener<K extends keyof MonetizationEventMap>(
        type: K,
        listener: EventListenerOrListenerObject<Monetization, MonetizationEventMap[K]> | null,
        options?: boolean | AddEventListenerOptions
    ): void

    removeEventListener<K extends keyof MonetizationEventMap>(
        type: K,
        listener: EventListenerOrListenerObject<Monetization, MonetizationEventMap[K]> | null,
        options?: boolean | EventListenerOptions
    ): void
}

declare global {
    interface Document {
        monetization?: Monetization
    }
}

/**
 * A Payment Configuration Object.
 *
 * @interface PaymentConfig
 * @field paymentPointer -TODO
 * @field pointerName - TODO
 * @field weight - An optional weight to give the payment. A value between 0 and 100.
 */
export interface PaymentConfig
{
    paymentPointer: string;
    pointerName?: string;
    weight?: number;
}

export class GameWebMonetization extends EventEmitter {

    /**
     * The event is emitted when the monetization is started, with this event you can show or hiden some ads or give some powerup to player.
     * 
     * @event
     * @type {object}
     * @property {string} paymentPointer - Your payment account URL. The same value is used as the content in your <meta> tag.
     * @property {string} requestId - This value is identical to the session ID/monetization ID (UUID v4) generated by the user agent (see Flow).
     * @example
     * ```js
     * // Receives
     * {
     *   paymentPointer: "$wallet.example.com/alice",
     *   requestId: ec4f9dec-0ba4-4029-8f6a-29dc21f2e0ce
     * }
     * ```
     */
    static START: string = 'start';

    /**
     * The event is emitted while web monetization is preparing to start to monetize your site.
     * 
     * @event
     * @type {object}
     * @property {string} paymentPointer - Your payment account URL. The same value is used as the content in your <meta> tag.
     * @property {string} requestId - This value is identical to the session ID/monetization ID (UUID v4) generated by the user agent (see Flow).
     * @example
     * ```js
     * // Receives
     * {
     *   paymentPointer: "$wallet.example.com/alice",
     *   requestId: ec4f9dec-0ba4-4029-8f6a-29dc21f2e0ce
     * }
     * ```
     */
    static PENDING: string = 'pending';

    /**
     * The event is emitted when the monetization is stopped.
     * 
     * @event
     * @type {object}
     * @property {string} paymentPointer - Your payment account URL. The same value is used as the content in your <meta> tag.
     * @property {string} requestId - This value is identical to the session ID/monetization ID (UUID v4) generated by the user agent (see Flow).
     * @property {boolean} finalized - When true, the monetization tag has been removed or the paymentPointer changed. No more events with this requestId expected.
     * @example
     * ```js
     * // Receives
     * {
     *   paymentPointer: "$wallet.example.com/alice",
     *   requestId: ec4f9dec-0ba4-4029-8f6a-29dc21f2e0ce,
     *   finalized: false
     * }
     * ```
     */
    static STOP: string = 'stop';

    /**
     * @typedef {object} ProgressEvent - Progress Event.
     * @property {string} paymentPointer - Your payment account URL. The same value is used as the content in your <meta> tag.
     * @property {string} requestId - This value is identical to the session ID/monetization ID (UUID v4) generated by the user agent (see Flow).
     * @property {string} amount - The destination amount received as specified in the Interledger protocol (ILP) packet.
     * @property {string} assetCode - The code (typically three characters) identifying the amount's unit. A unit, for example, could be a currency (USD, XRP).
     * @property {number} assetScale - The number of places past the decimal for the amount. For example, if you have USD with an asset scale of two, then the minimum divisible unit is cents.
     * @property {string} receipt - base64-encoded STREAM receipt issued by the Web Monetization receiver to the Web Monetization provider as proof of the total amount received in the stream.
     * @property {number} totalAmount - the sum of what has been received with the current paymentPointer, if the paymentPointer is changed this amount will be reset
     */

    /**
     * The event is emitted when the monetization progress.
     * 
     * The handler receives a {@link ProgressEvent} object.
     * 
     * @event
     * @example
     * ```js
     * // Receives
     * {
     *   paymentPointer: "$wallet.example.com/alice",
     *   requestId: "ec4f9dec-0ba4-4029-8f6a-29dc21f2e0ce",
     *   amount: "7567",
     *   assetCode: "USD",
     *   assetScale: 2,
     *   receipt: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAPoAAAAAF5h2Mk=",
     *   totalAmount: 0.000328153
     * }
     * ```
     */
    static PROGRESS: string = 'progress';

    /**
     * TODO
     * 
     * @readonly
     */
    paymentPointer: string;

    /**
     * This member helps to know the name of paymentPointer if the user has been
     * passed it in configuration.
     * 
     * @readonly
     */
    pointerName: string;

    /**
     * TODO
     */
    total: number = 0;

    /**
     * TODO
     */
    initializeEvents: boolean = true;

    /**
     * This member helps to know if the monetization is active or not.
     * 
     * @readonly
     */
    isMonetized: boolean = false;

    /**
     * This member helps to know the actual state of webmonetization.
     * This state could be: "started" or "stopped" or "pending" or undefined.
     * 
     * @readonly
     */
    state: string;

    /**
     * Creates an instance of the GameWebMonetization class.
     * 
     * TODO - Add lots more detail here.
     * 
     * @example
     * ```js
     * new GameWebMonetization({
     *   paymentPointer: $ilp.uphold.com/zdXzL8aWJ4ii,
     *   pointerName: "Richard"
     * });
     * ```
     * 
     * If you want to divide your earnings you can use Probalistic Revenue Sharing.
     * The weight is necesary to know how have more opportunity to be selected each
     * time to game is started (this use Probalistic Revenue Sharing,
     * more information {@link https://webmonetization.org/docs/probabilistic-rev-sharing|HERE}
     * 
     * @example
     * ```js
     * new GameWebMonetization([
     *   {
     *     paymentPointer: $ilp.uphold.com/zdXzL8aWJ4ii,
     *     pointerName: "Gamma",
     *     weight: 20
     *   },
     *   {
     *     paymentPointer: $ilp.uphold.com/zdXzL8aWJ4ii,
     *     pointerName: "Richard",
     *     weight: 80
     *   }
     * ]);
     * ```
     * @param config The Payment Configuration object, or an array of them.
     */
    constructor (config: PaymentConfig | PaymentConfig[])
    {
        super();

        this.changePaymentPointer(config);
        this.setStatate();
    }

    /**
     * This method helps us to try to initialize the monetization.
     * 
     * @returns The GameWebMonetization instance.
     */
    start (): this
    {
        this.setEvents();
        this.setMeta();

        return this;
    }

    /**
     * Stop the monetization.
     * 
     * @returns The GameWebMonetization instance.
     */
    stop (): this
    {
        this.removeMeta();

        return this;
    }

    /**
     * Sets payment or payments pointer by configuration.
     * 
     * To make efective the change you need use stop and start methods.
     *
     * @param config The Payment Configuration object, or an array of them.
     * @returns The GameWebMonetization instance.
     */
    changePaymentPointer (config: PaymentConfig | PaymentConfig[]): this
    {
        let paymentPointers: PaymentConfig[];

        if (!Array.isArray(config))
        {
            paymentPointers = [ { ...config, weight: 100 } ];
        }
        else
        {
            paymentPointers = config;
        }

        const paymentPointer = this.pickPointer(paymentPointers);

        if (paymentPointer !== undefined)
        {
            const pointerName = paymentPointers.find(pointer => {
                return pointer.paymentPointer === paymentPointer;
            }).pointerName;

            this.pointerName = pointerName;
        }

        this.setPaymentPointer(paymentPointer);

        return this;
    }

    /**
     * Handles the paymentPointer and set it in this.paymentPointer member.
     *
     * @param paymentPointer TODO
     * @private
     */
    setPaymentPointer (paymentPointer: string): void
    {
        if (paymentPointer === undefined || paymentPointer === null || paymentPointer.trim() === '')
        {
            console.error('Invalid paymentPointer, please check your configuration');
        }

        this.paymentPointer = paymentPointer;
    }

    /**
     * Help to select one paymentPointer from the configuration
     * 
     * @param pointers An array of Payment Configuration objects.
     * @returns TODO
     * @private
     */
    pickPointer (pointers: PaymentConfig[]): string
    {
        const sum = Object.values(pointers).reduce((sum, pointers) => {
            const weight = pointers.weight;
            return sum + weight
        }, 0);

        let choice = Math.random() * sum;

        for (const pointer in pointers)
        {
            const weight = pointers[pointer].weight;

            if ((choice -= weight) <= 0)
            {
                return pointers[pointer].paymentPointer;
            }
        }
    }

    /**
     * Help to get the the total of amount and emit the progress event.
     *
     * @param event The 'monetizationprogress' event.
     * @private
     */
    onProgress (event: MonetizationProgressEvent)
    {
        this.total += Number(event.detail.amount);

        const formatted = (this.total * Math.pow(10, -event.detail.assetScale)).toFixed(event.detail.assetScale);

        this.emit(GameWebMonetization.PROGRESS, { ...event.detail, 'totalAmount': formatted });
    }

    /**
     * Help to initialized all events
     *
     * @private
     */
    setEvents ()
    {
        if (this.state === 'stopped' && this.initializeEvents)
        {
            document.monetization.addEventListener('monetizationstart', event =>
            {
                this.setStatate();
                this.isMonetized = true;
                this.emit(GameWebMonetization.START, event.detail);
            });

            document.monetization.addEventListener('monetizationpending', (event) => {
                this.emit(GameWebMonetization.PENDING, event.detail);
            });

            document.monetization.addEventListener('monetizationstop', (event) => {
                if (this.state !== 'stopped') {
                    this.setStatate();
                    this.isMonetized = false;
                    this.emit(GameWebMonetization.STOP, event.detail);
                }
            });

            document.monetization.addEventListener('monetizationprogress', (event) => this.onProgress(event));

            this.initializeEvents = false;
        }
    }

    /**
     * Help to set the actual monetization state.
     * 
     * @private
     */
    setStatate (): void
    {
        this.state = typeof document && document.monetization && document.monetization.state;
    }

    /**
     * Help to insert the metatag to monetized your content in the HTML header.
     * 
     * @private
     */
    setMeta (): void
    {
        const checkMeta = document.querySelector('meta[name="monetization"]');
        const monetizationTag = document.createElement('meta');

        monetizationTag.setAttribute('name', 'monetization');
        monetizationTag.setAttribute('content', this.paymentPointer);

        if (this.state !== undefined)
        {
            if (checkMeta)
            {
                checkMeta.remove();
            }

            document.head.appendChild(monetizationTag);
        }
    }

    /**
     * Help to insert the metatag to monetized your content in the HTML header.
     * 
     * @private
     */
    removeMeta (): void
    {
        this.total = 0;

        const checkMeta = document.querySelector('meta[name="monetization"]');

        if (checkMeta)
        {
            checkMeta.remove();
        }
    }
}
